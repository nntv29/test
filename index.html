<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Yêu Em Trong Không Gian</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<!-- Three.js và OrbitControls -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/helvetiker_regular.typeface.json"></script>

<script>
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 100;

  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  const light = new THREE.PointLight(0xffc0cb, 1.5);
  light.position.set(50, 50, 50);
  scene.add(light);

  const ambient = new THREE.AmbientLight(0xff69b4, 0.5);
  scene.add(ambient);

  const texts = ["Yêu", "Em", "Nhiều", "Lắm", "❤️", "Vũ", "Trụ", "Mãi", "Bên", "Nhau"];

  const fontLoader = new THREE.FontLoader();

  const maxTextsBase = 40;
  const maxHeartsBase = 15;
  let textMeshes = [];

  let selectedMesh = null;
  let glowIntensity = 0;

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // Tạo text mesh
  function createTextMesh(font, text) {
    const geometry = new THREE.TextGeometry(text, {
      font: font,
      size: 3,
      height: 1,
      curveSegments: 8,
      bevelEnabled: true,
      bevelThickness: 0.2,
      bevelSize: 0.2,
      bevelSegments: 2
    });

    const material = new THREE.MeshPhongMaterial({
      color: 0xff69b4,
      emissive: 0xff1493,
      shininess: 100,
      emissiveIntensity: 1
    });

    const mesh = new THREE.Mesh(geometry, material);
    return mesh;
  }

  // Tạo hình trái tim mesh
  function createHeartMesh(heartGeo) {
    const heartMat = new THREE.MeshPhongMaterial({
      color: 0xff69b4,
      emissive: 0xff1493,
      emissiveIntensity: 1
    });
    const heart = new THREE.Mesh(heartGeo, heartMat);
    heart.scale.set(0.8, 0.8, 0.8);
    return heart;
  }

  fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function(font) {
    // Tạo shape trái tim
    const heartShape = new THREE.Shape();
    heartShape.moveTo(0, 0);
    heartShape.bezierCurveTo(0, 0, -2, -2, -2, -4);
    heartShape.bezierCurveTo(-2, -6, 0, -7, 0, -5);
    heartShape.bezierCurveTo(0, -7, 2, -6, 2, -4);
    heartShape.bezierCurveTo(2, -2, 0, 0, 0, 0);

    const heartGeo = new THREE.ExtrudeGeometry(heartShape, {
      depth: 1,
      bevelEnabled: true,
      bevelSegments: 2,
      steps: 2,
      bevelSize: 0.3,
      bevelThickness: 0.3
    });

    function addObjects(numTexts, numHearts, range) {
      for(let i = 0; i < numTexts; i++) {
        const text = texts[Math.floor(Math.random()*texts.length)];
        const mesh = createTextMesh(font, text);
        mesh.position.set(
          (Math.random() - 0.5)*range,
          (Math.random() - 0.5)*range,
          (Math.random() - 0.5)*range
        );
        scene.add(mesh);
        textMeshes.push({
          mesh: mesh,
          velocity: new THREE.Vector3(
            (Math.random() - 0.5)*0.3,
            -(Math.random())*0.5,
            (Math.random() - 0.5)*0.3
          )
        });
      }
      for(let i = 0; i < numHearts; i++) {
        const heart = createHeartMesh(heartGeo);
        heart.position.set(
          (Math.random() - 0.5)*range,
          (Math.random() - 0.5)*range,
          (Math.random() - 0.5)*range
        );
        scene.add(heart);
        textMeshes.push({
          mesh: heart,
          velocity: new THREE.Vector3(
            (Math.random() - 0.5)*0.2,
            -Math.random()*0.3,
            (Math.random() - 0.5)*0.2
          )
        });
      }
    }

    // Tạo ban đầu
    addObjects(maxTextsBase, maxHeartsBase, 200);

    // Bắt sự kiện click chọn mesh
    renderer.domElement.addEventListener('click', event => {
      mouse.x = (event.clientX / window.innerWidth)*2 - 1;
      mouse.y = -(event.clientY / window.innerHeight)*2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(textMeshes.map(obj => obj.mesh));
      if(intersects.length > 0) {
        const picked = intersects[0].object;
        if(selectedMesh !== picked) {
          if(selectedMesh) {
            selectedMesh.material.emissiveIntensity = 1;
          }
          selectedMesh = picked;
          glowIntensity = 0;
        }
      } else {
        selectedMesh = null;
      }
    });

    function animate() {
      requestAnimationFrame(animate);

      textMeshes.forEach(obj => {
        obj.mesh.position.add(obj.velocity);
        if(obj.mesh.position.y < -100) obj.mesh.position.y = 100;

        if(obj.mesh === selectedMesh) {
          glowIntensity += 0.02;
          if(glowIntensity > 5) glowIntensity = 5;
          obj.mesh.material.emissiveIntensity = glowIntensity;
        } else {
          if(obj.mesh.material.emissiveIntensity > 1) {
            obj.mesh.material.emissiveIntensity -= 0.02;
            if(obj.mesh.material.emissiveIntensity < 1) obj.mesh.material.emissiveIntensity = 1;
          }
        }
      });

      controls.update();
      renderer.render(scene, camera);

      if(camera.position.z > 120) {
        const desiredCount = Math.floor((camera.position.z - 100)*2) + maxTextsBase + maxHeartsBase;
        if(textMeshes.length < desiredCount) {
          const toAdd = desiredCount - textMeshes.length;
          const addTexts = Math.floor(toAdd*maxTextsBase/(maxTextsBase + maxHeartsBase));
          const addHearts = toAdd - addTexts;
          const range = 200 + (camera.position.z - 100)*10;
          addObjects(addTexts, addHearts, range);
        }
      }
    }

    animate();
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

</script>

</body>
</html>
