<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <title>Yêu Em Trong Không Gian</title>
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: black;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>

<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 100;
const renderer = new THREE.WebGLRenderer({antialias: true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new THREE.OrbitControls(camera, renderer.domElement);

const light = new THREE.PointLight(0xffc0cb, 1.5);
light.position.set(50, 50, 50);
scene.add(light);
scene.add(new THREE.AmbientLight(0xff69b4, 0.5));

const starsGeometry = new THREE.BufferGeometry();
const starCount = 1000;
const starVertices = [];
for (let i = 0; i < starCount; i++) {
  starVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
}
starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
const stars = new THREE.Points(starsGeometry, starsMaterial);
scene.add(stars);

const texts = ["I love you 3000","To me, you are perfect",  "❤️", "You are my everything <3", 
               "You are my sunshine", "I love you", "You’re my soulmate", 
               "Believe in the spirit of love… It can heal all things.
","I’m lost in your eyes","Believe in the spirit of love… It can heal all things..."];
const fontLoader = new THREE.FontLoader();

const maxTextsBase = 40, maxHeartsBase = 15;
let textMeshes = [], selectedMesh = null, glowIntensity = 0;
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const emissiveDefault = new THREE.Color(0xff1493);
const emissiveGlow = new THREE.Color(0xffffff);

fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
  const heartShape = new THREE.Shape();
  heartShape.moveTo(0, 0);
  heartShape.bezierCurveTo(0, 0, -2, -2, -2, -4);
  heartShape.bezierCurveTo(-2, -6, 0, -7, 0, -5);
  heartShape.bezierCurveTo(0, -7, 2, -6, 2, -4);
  heartShape.bezierCurveTo(2, -2, 0, 0, 0, 0);
  const heartGeo = new THREE.ExtrudeGeometry(heartShape, {
    depth: 1, bevelEnabled: true, bevelSegments: 2, steps: 2,
    bevelSize: 0.3, bevelThickness: 0.3
  });

  function createTextMesh(text) {
    const geo = new THREE.TextGeometry(text, {
      font: font, size: 3, height: 1, curveSegments: 8,
      bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 2
    });
    const mat = new THREE.MeshPhongMaterial({ color: 0xff69b4, emissive: emissiveDefault.clone(), shininess: 100 });
    return new THREE.Mesh(geo, mat);
  }

  function createHeartMesh() {
    const mat = new THREE.MeshPhongMaterial({ color: 0xff69b4, emissive: emissiveDefault.clone() });
    const mesh = new THREE.Mesh(heartGeo, mat);
    mesh.scale.set(0.8, 0.8, 0.8);
    return mesh;
  }

  function addObjects(numTexts, numHearts, range) {
    for (let i = 0; i < numTexts; i++) {
      const mesh = createTextMesh(texts[Math.floor(Math.random() * texts.length)]);
      mesh.position.set((Math.random() - 0.5) * range, (Math.random() - 0.5) * range, (Math.random() - 0.5) * range);
      scene.add(mesh);
      textMeshes.push({ mesh, velocity: new THREE.Vector3((Math.random() - 0.5) * 0.3, -Math.random() * 0.5, (Math.random() - 0.5) * 0.3) });
    }
    for (let i = 0; i < numHearts; i++) {
      const mesh = createHeartMesh();
      mesh.position.set((Math.random() - 0.5) * range, (Math.random() - 0.5) * range, (Math.random() - 0.5) * range);
      scene.add(mesh);
      textMeshes.push({ mesh, velocity: new THREE.Vector3((Math.random() - 0.5) * 0.2, -Math.random() * 0.3, (Math.random() - 0.5) * 0.2) });
    }
  }

  addObjects(maxTextsBase, maxHeartsBase, 200);

  let dragging = false, dragObject = null, dragOffset = new THREE.Vector3(), lastMouse = new THREE.Vector2(), throwVelocity = new THREE.Vector3();

  renderer.domElement.addEventListener('mousedown', event => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(textMeshes.map(o => o.mesh));
    if (intersects.length > 0) {
      dragObject = intersects[0].object;
      dragging = true;
      controls.enabled = false;
      dragOffset.copy(intersects[0].point).sub(dragObject.position);
      lastMouse.set(event.clientX, event.clientY);
    }
  });

  renderer.domElement.addEventListener('mousemove', event => {
    if (dragging && dragObject) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), -camera.position.z + 50);
      const pos = new THREE.Vector3();
      raycaster.ray.intersectPlane(planeZ, pos);
      dragObject.position.copy(pos.sub(dragOffset));
      const dx = event.clientX - lastMouse.x;
      const dy = event.clientY - lastMouse.y;
      throwVelocity.set(dx * 0.05, -dy * 0.05, 0);
      lastMouse.set(event.clientX, event.clientY);
    }
  });

  renderer.domElement.addEventListener('mouseup', () => {
    if (dragging && dragObject) {
      const item = textMeshes.find(o => o.mesh === dragObject);
      if (item) item.velocity.copy(throwVelocity);
    }
    dragging = false;
    dragObject = null;
    controls.enabled = true;
  });

  renderer.domElement.addEventListener('click', event => {
    if (dragging) return;
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(textMeshes.map(o => o.mesh));
    if (intersects.length > 0) {
      if (selectedMesh) selectedMesh.material.emissive.copy(emissiveDefault);
      selectedMesh = intersects[0].object;
      glowIntensity = 0;
    } else if (selectedMesh) {
      selectedMesh.material.emissive.copy(emissiveDefault);
      selectedMesh = null;
    }
  });

  function animate() {
    requestAnimationFrame(animate);
    stars.rotation.y += 0.0005;
    textMeshes.forEach(obj => {
      if (obj.mesh !== dragObject) obj.mesh.position.add(obj.velocity);
      if (obj.mesh.position.y < -100) obj.mesh.position.y = 100;

      if (obj.mesh === selectedMesh) {
        glowIntensity += 0.05;
        if (glowIntensity > 1) glowIntensity = 1;
        obj.mesh.material.emissive.lerpColors(emissiveDefault, emissiveGlow, glowIntensity);
      } else {
        glowIntensity -= 0.02;
        if (glowIntensity < 0) glowIntensity = 0;
        obj.mesh.material.emissive.lerpColors(obj.mesh.material.emissive, emissiveDefault, 0.1);
      }
    });

    controls.update();
    renderer.render(scene, camera);

    if (camera.position.z > 120) {
      const desiredCount = Math.floor((camera.position.z - 100) * 2) + maxTextsBase + maxHeartsBase;
      if (textMeshes.length < desiredCount) {
        const toAdd = desiredCount - textMeshes.length;
        const addTexts = Math.floor(toAdd * maxTextsBase / (maxTextsBase + maxHeartsBase));
        const addHearts = toAdd - addTexts;
        const range = 200 + (camera.position.z - 100) * 10;
        addObjects(addTexts, addHearts, range);
      }
    }
  }

  animate();
});

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
